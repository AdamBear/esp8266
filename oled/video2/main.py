from machine import Pin, SPI
from ssd1306 import SSD1306_SPI   # 导入SSD控制的OLED程序
import network
import time

# 连接无线网络的，这里就不多说了，前面有单独视频讲解
net = network.WLAN(network.STA_IF)
if not net.isconnected():
    net.active(True)
    net.connect("Lily", "Meiyoumima")
    while not net.isconnected():
        time.sleep(1)
# fonts 和 fonts2 为我们处理后的取模数据
fonts = [
        # 西
        [0x40, 0x40, 0x47, 0x44, 0x44, 0x7F, 0x44, 0x44, 0x44, 0x7F, 0x44, 0x44, 0x47, 0x40, 0x40, 0x00,
         0x00, 0x00, 0xFF, 0x12, 0x22, 0xC2, 0x02, 0x02, 0x02, 0xC2, 0x22, 0x22, 0xFF, 0x00, 0x00, 0x00],
        # 瓜
        [0x00, 0x00, 0x00, 0x3F, 0x20, 0x20, 0x3F, 0x20, 0x40, 0x40, 0x7F, 0xC0, 0x40, 0x00, 0x00, 0x00,
         0x01, 0x06, 0x18, 0xE0, 0x00, 0x00, 0xFE, 0x04, 0x28, 0x10, 0x8C, 0x70, 0x0C, 0x02, 0x01, 0x00],
        # 抖
        [0x08, 0x08, 0x08, 0xFF, 0x08, 0x09, 0x00, 0x44, 0x33, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
         0x20, 0x22, 0x41, 0xFE, 0x80, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0xFF, 0x40, 0x40, 0x40, 0x00],
        # 音
        [0x02, 0x02, 0x22, 0x22, 0x2A, 0x26, 0xA2, 0x62, 0x22, 0x26, 0x2A, 0x22, 0x22, 0x02, 0x02, 0x00,
         0x00, 0x00, 0x00, 0xFF, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0xFF, 0x00, 0x00, 0x00, 0x00],
        # 头
        [0x00, 0x00, 0x08, 0x06, 0x20, 0x18, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x81, 0x81, 0x82, 0x82, 0x84, 0x88, 0x90, 0xE0, 0x80, 0xA0, 0x90, 0x88, 0x84, 0x83, 0x80, 0x00],
        # 条
        [0x01, 0x09, 0x09, 0x12, 0x32, 0xEA, 0x24, 0x27, 0x24, 0x2A, 0x32, 0x22, 0x01, 0x01, 0x01, 0x00,
         0x00, 0x42, 0x44, 0x48, 0x50, 0x42, 0x41, 0xFE, 0x40, 0x40, 0x50, 0x48, 0x44, 0x42, 0x00, 0x00],
        # 一
        [0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        # 点
        [0x00, 0x00, 0x03, 0x02, 0x02, 0x02, 0xFE, 0x12, 0x12, 0x12, 0x12, 0x13, 0x10, 0x10, 0x00, 0x00,
         0x01, 0x02, 0xEC, 0x20, 0x20, 0x28, 0x26, 0x20, 0x28, 0x26, 0x20, 0xE0, 0x08, 0x07, 0x00, 0x00]
]

fonts2 = [
    # 小
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F,
     0x1F, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x3E, 0x1C, 0x10, 0x00, 0x00, 0x00, 0xFF,
     0xFF, 0x00, 0x00, 0x00, 0x00, 0x10, 0x08, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x01, 0x02, 0x0C, 0x18, 0x70, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0x7C, 0x3E, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x08, 0x0C, 0x0E, 0xFC,
     0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    # 杜
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x1F, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x1F, 0x0F, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x47, 0xFF, 0xFF, 0x44, 0x42, 0x41, 0xC1, 0xC0, 0x44, 0x04,
     0x04, 0x04, 0x04, 0x04, 0xFF, 0xFF, 0x04, 0x04, 0x04, 0x04, 0x0C, 0x0C, 0x04, 0x00, 0x00, 0x00,
     0x00, 0x01, 0x02, 0x0C, 0x38, 0xE0, 0x80, 0xFF, 0xFF, 0x00, 0x00, 0x80, 0xE0, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFC, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10,
     0x10, 0x10, 0x10, 0x10, 0xF0, 0xF0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0x30, 0x10, 0x00, 0x00],
    # L
    [0x00, 0x02, 0x02, 0x03, 0x03, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
     0x00, 0x10, 0x10, 0xF0, 0xF0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0x70, 0x80, 0x00],
    # a
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x01, 0x03, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00,
     0x00, 0x03, 0xC7, 0xCC, 0x08, 0x18, 0x10, 0x10, 0x10, 0x10, 0x20, 0xFF, 0xFF, 0x00, 0x00, 0x00,
     0x00, 0xC0, 0xE0, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x20, 0x20, 0xE0, 0xF0, 0x10, 0x10, 0x60],
    # b
    [0x00, 0x02, 0x02, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0xFF, 0xFF, 0x01, 0x02, 0x04, 0x04, 0x04, 0x06, 0x03, 0x03, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
     0x00, 0x00, 0x00, 0xF0, 0xE0, 0x60, 0x10, 0x10, 0x10, 0x10, 0x30, 0x60, 0xC0, 0x00, 0x00, 0x00]
]

# OLDE连线示意，ESP8266开发板
# SCK ---> D5 ---> 14
# MOSI --> D6 ---> 12
# MIOS --> Null-->任意没有用的
# DC   --> D8 ---> 15
# RES  --> D7 ---> 13
# CS   --> Null-->本次使用6针没有该引脚,指定一个空引脚即可
# 根据上面的连线，定义各个IO接口变量
SCK = Pin(14, Pin.OUT)
MOSI = Pin(12, Pin.OUT)
MISO = Pin(0)
DC = Pin(15)
RES = Pin(13)
CS = Pin(16)
# 初始化SPI对象，sck,mosi，miso 三个参数是必须的
spi = SPI(sck=SCK, mosi=MOSI, miso=MISO)
# 初始化OLED对象，128*64 是屏幕的分辨率，所谓的大小
display = SSD1306_SPI(128, 64, spi, dc=DC, res=RES, cs=CS)
# 打开SPI通道
display.poweron()
# 初始化OLED显示
display.init_display()

# 显示西瓜抖音头条一点，字体大小为16*16像素大小
x = 0  # 横向我们从0像素点开始显示，也就是左上角
for f in fonts:  # 从列表中依次取每个字的数据
    for index in range(0, 16):  # 由于我们设置的字体宽度是16像素，每个字我们有16列，
        # 取每一列的数据，由于我们用的C51格式，每个数据，都有8个值，也就是8行,我们把二进制的数据中的0b前置项去掉，方便后续的补零操作。
        a1 = bin(f[index]).replace("0b", "")
        while len(a1) < 8:  # 如果数据不满8位，我们在数据前面加0进行补齐
            a1 = "0" + a1
        #  一个数据代表8行，我们设计的一个字体高度是16也就是16行，所有一列有两个数据组成，我们取第二个数据
        #  我们选择的列行模式，先把第一段行数据列取完，在取下一个数据列，我们字体宽度是16像素，所有我们前16个数据是第一行的数据组
        #  从第17个数据开始就是下一个数据行的开始也就是第二个数据，列表的开始为0，所有这里我们偏移16去取第二个数据
        a2 = bin(f[index + 16]).replace("0b", "")
        while len(a2) < 8:  # 这里我们进行第二组数据位数补齐
            a2 = "0" + a2

        # 我们开始在屏幕上布局显示我们的像素点
        for y in range(0, 8):   # 我们一组数据是8行数据，就是y轴会有8个像素点
            # 显示第一组数据，x 行的位置， y 列的位置， 后面为当前位置是否需要亮，我们一定要转换成int类型
            display.pixel(x, y, int(a1[y]))
            # 第二组数据列需要偏移8个像素点开始
            display.pixel(x, y + 8, int(a2[y]))
        # 一行显示完成后，循环显示下一行数据
        x += 1
    # 一个字符处理完成，在屏幕上显示这个文字
    display.show()

# 显示小杜LAB 字体，字体大小是32*32 像素
x_offset = 8   # 在行上我们这里向右移动8个像素开始显示，相当于缩进
y_offset = 32  # 列上，上面一段文字显示用了16行，由于空间足，这里我们在向下移动16像素在显示，这里y轴就初始偏移32像素

for f in fonts2:
    # 我们设置的字体大小是32*32 像素，由于英文字符是16*32 像素，我们先判断下字符有多少个列数据，
    # 已知我们一个数据是8行数据，我们字体是32行，用总数据量除以4个8行，那么剩下就是我们有几列数据
    pix_row = int(int(len(f))/4)
    for index in range(0, pix_row):  # 取每一列数据 （0-7行）
        row1 = bin(f[index]).replace("0b", "")  # 数据替换，
        while len(row1) < 8:    # 数据位数补齐
            row1 = "0" + row1
        # 取第二个数据行（8-15行），我们上面已经计算出有多少列数据pix_row
        row2 = bin(f[index + pix_row]).replace("0b", "")
        while len(row2) < 8:
            row2 = "0" + row2
        # 取第三个数据行(16-24行)
        row3 = bin(f[index + (pix_row * 2)]).replace("0b", "")
        while len(row3) < 8:
            row3 = "0" + row3
        # 取第四个数据行(25-31行)
        row4 = bin(f[index + (pix_row * 3)]).replace("0b", "")
        while len(row4) < 8:
            row4 = "0" + row4

        for y in range(0, 8):  # 进行指定列，每一行数据显示，一个数据是8行。
            if int(row1[y]):  # 这里优化下，如果像素点是0不亮的话我们直接跳过
                # 第一个数据行，y轴，这里我们需要把上面显示的文字，空出来，Y轴需要向下偏移
                display.pixel(x_offset, y + y_offset, int(row1[y]))
            if int(row2[y]):
                # 第二个数据行
                display.pixel(x_offset, y + 8 + y_offset, int(row2[y]))
            if int(row3[y]):
                # 第三个数据行
                display.pixel(x_offset, y + 16 + y_offset, int(row3[y]))
            if int(row4[y]):
                # 第四个数据行
                display.pixel(x_offset, y + 24 + y_offset, int(row4[y]))
        # 循环进入下一列数据显示
        x_offset += 1
        # 这里每一列数据完成就开始现实，我们可以就能看到效果了
        display.show()
